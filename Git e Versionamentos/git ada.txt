#DICAS
Ao usar git log, aperta Q para sair


-------------

roda na maioria localmente, praticamente instantâneo por causa disso.
salva o caminho e a referencia para aquele momento do código
snapshot, foto de como estava

Sempre que iniciamos um projeto com git, há uma pasta oculta chamada .git
utiliza para acessar versões antigas e salvar outras opções ao longo do versionamento.

git init inicializa o git no projeto e cria essa pasta .git que fará o controle de versionamento

Estados do git
untracked - não monitorado
unmodified - não modificado
modified - modificado
staged - preparado para o commit

Exemplos de estados
Untracked (Não Monitorado)
São arquivos novos que o Git ainda não conhece
Exemplo: Quando você cria um novo arquivo

Unmodified (Não Modificado)
Arquivos que já estão no controle do Git e não sofreram alterações desde o último commit, 
Logo após fazer um commit, todos os arquivos ficam neste estado

Modified (Modificado)
Arquivos que já estão no controle do Git e sofreram alterações,
Quando você edita um arquivo que já estava commitado.

Staged (Preparado)
Arquivos que estão prontos para serem commitados
É uma área temporária onde você prepara o que vai entrar no próximo commit

Fluxo
A[Untracked] -->|git add| D[Staged]
    B[Modified] -->|git add| D
    D -->|git commit| C[Unmodified]
    C -->|editar arquivo| B
    C -->|git rm| A
    D -->|git reset HEAD| B

Resumindo
Untracked = novos arquivos
Modified = arquivos que sofreram alterações
Staged = arquivos prontos para o commit / usando git add
Unmodified = arquivos que já foram commitados e não sofreram alterações desde o último commit.

O estado Staged é exclusivamente alcançado através do comando git add.
É como um processo de duas etapas:
Primeiro: git add → coloca na área Staged
Depois: git commit → salva definitivamente
    A[Arquivo] -->|git add| B[Staged] -->|git commit| C[Commit/Unmodified]

se usar git add, o arquivo passa para o estado staged
se usar git commit, o arquivo passa para o estado unmodified
se usar git checkout -- arquivo, o arquivo passa para o estado unmodified
se usar git reset HEAD arquivo, o arquivo passa para o estado modified
se usar git rm arquivo, o arquivo passa para o estado untracked


git diff mostra as diferenças entre o modified e o unmodified(arquivos que já foram commitados)
git diff --staged mostra as diferenças entre o staged (arquivos que estão prontos para o commit com git add) e o unmodified.



git add adiciona o arquivo para o staging area

git add . adiciona todos os arquivos para o staging area

git commit -m "mensagem" cria um commit com a mensagem

git status mostra o que foi modificado

git log mostra o histórico de commits

git checkout -- arquivo desfaz o que foi modificado no arquivo

Quero fazer um segundo commit com a mesma descrição, pois estou alterando um arquivo de texto
git commit --amend --no-edit
--amend modifica o último commit
--no-edit não altera a mensagem do commit
esse comando faz o commit com a mesma mensagem do commit anterior caso ainda não tenha enviado para o repositório remoto.

para criar um novo commit com a mesma mensagem anterior, mas com alterações no arquivo

git commit -C HEAD
-C significa "reutilizar mensagem de commit"
HEAD é uma referência para o último commit

-C HEAD copia:
A mensagem do commit
A data/hora do commit original
Mas mantém um hash único para cada commit


git restore arquivo desfaz as alterações no arquivo
Ou seja, se eu escrever algo no código e salvar mas sem dar git add, posso usar o git restore para desfazer as alterações.

git restore --staged arquivo desfaz o git add, porém as alterações ainda permanecem no arquivo.

cria arquivo> git add> git commit> git push

git remote mostra a branch do repositório remoto (origin)
git branch mostra a branch local (main)

git push remote local
git push origin main

Neste projeto em si eu posso simplesmente usar git push porém em um projeto real, o ideal é usar git push branch-remota branch-local para evitar erros.

git pull origin main
Para atualizar a branch local caso a branch remota tenha sido atualizada e eu não ter essa versão ainda.

git fetch origin main
Para trazer a informação da branch remota porém ainda não foi mesclada com a branch local.
Pode-se usar git diff branch-remota/branch-local para ver as diferenças.

git merge origin/main
Aplica as mudanças da branch remota para a branch local.

Então entende-se que git pull = git fetch + git merge
--------------
Branches

main é a branch principal
main>commit1>commit2>commit3

git branch
mostra as Branches

git branch nome-branch
cria uma nova branch

git checkout nome-branch
muda para a branch nome-branch

git checkout -b nome-branch
cria e muda para a branch nome-branch

git log --oneline --decorate --graph --all
Aparece o histórico de commits com o nome das branches e onde o HEAD está apontando, que seria a branch atual e também o ultimo commit.

HEAD -> test, origin/main, origin/HEAD, main) Update README.md
6e915fe Update README.md
a694c21 Atualiza informacoes das anotacoes

Se eu fizer um commit nessa nova branch e quiser retornar para a outra branch, a outra branch não terá esse novo commit.


main>commit1>commit2
test>commit1>commit2>commit3
para mesclar as duas branches, posso usar git merge test main
main>commit1>commit2>commit4
test>commit1>commit2>commit3


